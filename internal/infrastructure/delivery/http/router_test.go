package httprouter_test

import (
	"daunrodo/internal/config"
	"daunrodo/internal/downloader"
	httprouter "daunrodo/internal/infrastructure/delivery/http"
	"daunrodo/internal/observability"
	"daunrodo/internal/service"
	"daunrodo/internal/storage"
	"io"
	"log/slog"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"
	"time"
)

func TestRouter(t *testing.T) {
	used := ""

	mw1 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "1"

			next.ServeHTTP(w, r)
		})
	}

	mw2 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "2"

			next.ServeHTTP(w, r)
		})
	}

	mw3 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "3"

			next.ServeHTTP(w, r)
		})
	}

	mw4 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "4"

			next.ServeHTTP(w, r)
		})
	}

	mw5 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "5"

			next.ServeHTTP(w, r)
		})
	}

	mw6 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "6"

			next.ServeHTTP(w, r)
		})
	}

	handleFn := func(_ http.ResponseWriter, _ *http.Request) {}

	ctx := t.Context()
	log := slog.New(slog.NewTextHandler(os.Stdout, nil))
	downloader := downloader.NewMock(log)
	cfg := &config.Config{Storage: config.Storage{CleanupInterval: time.Minute}}
	storer := storage.New(ctx, log, cfg, nil)
	svc := service.New(cfg, log, downloader, storer, nil)

	router := httprouter.New(log, nil, svc, storer, nil)
	router.Use(mw1)
	router.Use(mw2)

	router.HandleFunc("GET /{$}", handleFn)

	router.Group(func(r *httprouter.Router) {
		r.Use(mw3, mw4)
		r.HandleFunc("GET /foo", handleFn)

		r.Group(func(r *httprouter.Router) {
			r.Use(mw5)
			r.HandleFunc("GET /nested/foo", handleFn)
		})
	})

	router.Group(func(r *httprouter.Router) {
		r.Use(mw6)
		r.HandleFunc("GET /bar", handleFn)
	})

	router.HandleFunc("GET /baz", handleFn)

	var tests = []struct {
		RequestMethod  string
		RequestPath    string
		ExpectedUsed   string
		ExpectedStatus int
	}{
		{
			RequestMethod:  "GET",
			RequestPath:    "/",
			ExpectedUsed:   "12",
			ExpectedStatus: http.StatusOK,
		},
		{
			RequestMethod:  "GET",
			RequestPath:    "/foo",
			ExpectedUsed:   "1234",
			ExpectedStatus: http.StatusOK,
		},
		{
			RequestMethod:  "GET",
			RequestPath:    "/nested/foo",
			ExpectedUsed:   "12345",
			ExpectedStatus: http.StatusOK,
		},
		{
			RequestMethod:  "GET",
			RequestPath:    "/bar",
			ExpectedUsed:   "126",
			ExpectedStatus: http.StatusOK,
		},
		{
			RequestMethod:  "GET",
			RequestPath:    "/baz",
			ExpectedUsed:   "12",
			ExpectedStatus: http.StatusOK,
		},
		// Check global middleware used on errors generated by http.ServeMux
		{
			RequestMethod:  "GET",
			RequestPath:    "/notfound",
			ExpectedUsed:   "12",
			ExpectedStatus: http.StatusNotFound,
		},
		{
			RequestMethod:  "POST",
			RequestPath:    "/nested/foo",
			ExpectedUsed:   "12",
			ExpectedStatus: http.StatusMethodNotAllowed,
		},
	}

	for _, test := range tests {
		used = ""

		req, err := http.NewRequestWithContext(ctx, test.RequestMethod, test.RequestPath, nil)
		if err != nil {
			t.Errorf("NewRequest: %s", err)
		}

		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)

		rs := rr.Result()

		if rs.StatusCode != test.ExpectedStatus {
			t.Errorf("%s %s: expected status %d but was %d",
				test.RequestMethod, test.RequestPath, test.ExpectedStatus, rs.StatusCode)
		}

		if used != test.ExpectedUsed {
			t.Errorf("%s %s: middleware used: expected %q; got %q",
				test.RequestMethod, test.RequestPath, test.ExpectedUsed, used)
		}
	}
}

func TestChain(t *testing.T) {
	ctx := t.Context()
	used := ""

	mw1 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "1"

			next.ServeHTTP(w, r)
		})
	}

	mw2 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "2"

			next.ServeHTTP(w, r)
		})
	}

	mw3 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "3"

			next.ServeHTTP(w, r)
		})
	}

	mw4 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "4"

			next.ServeHTTP(w, r)
		})
	}

	mw5 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "5"

			next.ServeHTTP(w, r)
		})
	}

	mw6 := func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			used += "6"

			next.ServeHTTP(w, r)
		})
	}

	handleFn := func(_ http.ResponseWriter, _ *http.Request) {}

	mux := http.NewServeMux()

	chain1 := httprouter.Chain{mw1, mw2}

	mux.Handle("GET /{$}", chain1.ThenFunc(handleFn))

	chain2 := append(chain1, mw3, mw4)
	mux.Handle("GET /foo", chain2.ThenFunc(handleFn))

	chain3 := append(chain2, mw5)
	mux.Handle("GET /nested/foo", chain3.ThenFunc(handleFn))

	chain4 := append(chain1, mw6)
	mux.Handle("GET /bar", chain4.ThenFunc(handleFn))

	mux.Handle("GET /baz", chain1.ThenFunc(handleFn))

	var tests = []struct {
		RequestMethod  string
		RequestPath    string
		ExpectedUsed   string
		ExpectedStatus int
	}{
		{
			RequestMethod:  "GET",
			RequestPath:    "/",
			ExpectedUsed:   "12",
			ExpectedStatus: http.StatusOK,
		},
		{
			RequestMethod:  "GET",
			RequestPath:    "/foo",
			ExpectedUsed:   "1234",
			ExpectedStatus: http.StatusOK,
		},
		{
			RequestMethod:  "GET",
			RequestPath:    "/nested/foo",
			ExpectedUsed:   "12345",
			ExpectedStatus: http.StatusOK,
		},
		{
			RequestMethod:  "GET",
			RequestPath:    "/bar",
			ExpectedUsed:   "126",
			ExpectedStatus: http.StatusOK,
		},
		{
			RequestMethod:  "GET",
			RequestPath:    "/baz",
			ExpectedUsed:   "12",
			ExpectedStatus: http.StatusOK,
		},
	}

	for _, test := range tests {
		used = ""

		r, err := http.NewRequestWithContext(ctx, test.RequestMethod, test.RequestPath, nil)
		if err != nil {
			t.Errorf("NewRequest: %s", err)
		}

		rr := httptest.NewRecorder()
		mux.ServeHTTP(rr, r)

		res := rr.Result()

		if res.StatusCode != test.ExpectedStatus {
			t.Errorf("%s %s: expected status %d but was %d",
				test.RequestMethod,
				test.RequestPath,
				test.ExpectedStatus,
				res.StatusCode)
		}

		if used != test.ExpectedUsed {
			t.Errorf("%s %s: middleware used: expected %q; got %q",
				test.RequestMethod,
				test.RequestPath,
				test.ExpectedUsed,
				used)
		}
	}
}

func TestRouterMetricsRoute(t *testing.T) {
	ctx := t.Context()

	log := slog.New(slog.NewTextHandler(os.Stdout, nil))
	cfg := &config.Config{Storage: config.Storage{CleanupInterval: time.Minute}}
	dl := downloader.NewMock(log)
	storer := storage.New(ctx, log, cfg, nil)
	svc := service.New(cfg, log, dl, storer, nil)
	metrics := observability.New()

	router := httprouter.New(log, cfg, svc, storer, metrics)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, "/metrics", nil)
	if err != nil {
		t.Fatalf("NewRequest: %v", err)
	}

	rr := httptest.NewRecorder()
	router.ServeHTTP(rr, req)

	res := rr.Result()
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		t.Fatalf("expected status %d but got %d", http.StatusOK, res.StatusCode)
	}

	body, err := io.ReadAll(res.Body)
	if err != nil {
		t.Fatalf("ReadAll: %v", err)
	}

	if !strings.Contains(string(body), "go_goroutines") {
		t.Fatalf("expected Go collector metric in response body")
	}
}
